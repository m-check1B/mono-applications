import{l as y}from"./RjzcECkQ.js";const p="focus-kraliki-offline",I=2,t={TASKS:"tasks",PROJECTS:"projects",KNOWLEDGE:"knowledge",KNOWLEDGE_TYPES:"knowledgeTypes",TIME_ENTRIES:"timeEntries",QUEUE:"syncQueue"};async function u(){return new Promise((e,c)=>{const a=indexedDB.open(p,I);a.onerror=()=>{y.error("Failed to open IndexedDB"),c(a.error)},a.onsuccess=()=>{e(a.result)},a.onupgradeneeded=r=>{const s=r.target.result;if(!s.objectStoreNames.contains(t.TASKS)){const n=s.createObjectStore(t.TASKS,{keyPath:"id"});n.createIndex("status","status",{unique:!1}),n.createIndex("dueDate","dueDate",{unique:!1}),n.createIndex("projectId","projectId",{unique:!1}),n.createIndex("updatedAt","updatedAt",{unique:!1})}if(!s.objectStoreNames.contains(t.PROJECTS)){const n=s.createObjectStore(t.PROJECTS,{keyPath:"id"});n.createIndex("name","name",{unique:!1}),n.createIndex("updatedAt","updatedAt",{unique:!1})}if(!s.objectStoreNames.contains(t.KNOWLEDGE)){const n=s.createObjectStore(t.KNOWLEDGE,{keyPath:"id"});n.createIndex("typeId","typeId",{unique:!1}),n.createIndex("completed","completed",{unique:!1}),n.createIndex("updatedAt","updatedAt",{unique:!1})}if(s.objectStoreNames.contains(t.KNOWLEDGE_TYPES)||s.createObjectStore(t.KNOWLEDGE_TYPES,{keyPath:"id"}).createIndex("name","name",{unique:!1}),!s.objectStoreNames.contains(t.TIME_ENTRIES)){const n=s.createObjectStore(t.TIME_ENTRIES,{keyPath:"id"});n.createIndex("taskId","taskId",{unique:!1}),n.createIndex("projectId","projectId",{unique:!1}),n.createIndex("startTime","startTime",{unique:!1})}if(!s.objectStoreNames.contains(t.QUEUE)){const n=s.createObjectStore(t.QUEUE,{keyPath:"id",autoIncrement:!0});n.createIndex("timestamp","timestamp",{unique:!1}),n.createIndex("type","type",{unique:!1})}}})}async function d(e,c){const a=await u();return new Promise((r,s)=>{const i=a.transaction([e],"readwrite").objectStore(e),o={...c,_offlineUpdatedAt:new Date().toISOString()},f=i.put(o);f.onsuccess=()=>r(),f.onerror=()=>s(f.error)})}async function S(e,c){const a=await u();return new Promise((r,s)=>{const o=a.transaction([e],"readonly").objectStore(e).get(c);o.onsuccess=()=>{r(o.result||null)},o.onerror=()=>s(o.error)})}async function l(e){const c=await u();return new Promise((a,r)=>{const i=c.transaction([e],"readonly").objectStore(e).getAll();i.onsuccess=()=>{a(i.result)},i.onerror=()=>r(i.error)})}async function E(e,c){const a=await u();return new Promise((r,s)=>{const o=a.transaction([e],"readwrite").objectStore(e).delete(c);o.onsuccess=()=>r(),o.onerror=()=>s(o.error)})}async function m(e){const c={id:crypto.randomUUID?.()||`queue-${Date.now()}`,...e,timestamp:new Date().toISOString(),retries:0,status:"pending"};await d(t.QUEUE,c)}async function O(){return l(t.QUEUE)}async function T(e){return E(t.QUEUE,e)}const b={async save(e){await d(t.TASKS,e)},async get(e){return S(t.TASKS,e)},async getAll(){return l(t.TASKS)},async delete(e){return E(t.TASKS,e)},async getByStatus(e){const c=await u();return new Promise((a,r)=>{const o=c.transaction([t.TASKS],"readonly").objectStore(t.TASKS).index("status").getAll(e);o.onsuccess=()=>a(o.result),o.onerror=()=>r(o.error)})}},P={async save(e){await d(t.PROJECTS,e)},async get(e){return S(t.PROJECTS,e)},async getAll(){return l(t.PROJECTS)},async delete(e){return E(t.PROJECTS,e)}},q={async save(e){await d(t.KNOWLEDGE,e)},async get(e){return S(t.KNOWLEDGE,e)},async getAll(){return l(t.KNOWLEDGE)},async delete(e){return E(t.KNOWLEDGE,e)},async getByType(e){const c=await u();return new Promise((a,r)=>{const o=c.transaction([t.KNOWLEDGE],"readonly").objectStore(t.KNOWLEDGE).index("typeId").getAll(e);o.onsuccess=()=>a(o.result),o.onerror=()=>r(o.error)})}},D={async save(e){await d(t.TIME_ENTRIES,e)},async get(e){return S(t.TIME_ENTRIES,e)},async getAll(){return l(t.TIME_ENTRIES)},async delete(e){return E(t.TIME_ENTRIES,e)}};function w(){return typeof navigator>"u"?!0:navigator.onLine}async function K(e){if(!w())return{success:0,failed:0,errors:[]};const c=await O(),a={success:0,failed:0,errors:[]};for(const r of c)try{switch(r.type){case"create":await e.post(r.endpoint,r.data);break;case"update":await e.patch(r.endpoint,r.data);break;case"delete":await e.delete(r.endpoint);break}await T(r.id),a.success++}catch(s){y.error(`Failed to sync operation ${r.id}`,s),a.failed++,a.errors.push({op:r,error:s})}return a}async function N(e){const c=await u();return new Promise((a,r)=>{const i=c.transaction([e],"readwrite").objectStore(e).clear();i.onsuccess=()=>a(),i.onerror=()=>r(i.error)})}const j={async save(e){await d(t.KNOWLEDGE_TYPES,e)},async get(e){return S(t.KNOWLEDGE_TYPES,e)},async getAll(){return l(t.KNOWLEDGE_TYPES)},async delete(e){return E(t.KNOWLEDGE_TYPES,e)}};export{t as O,q as a,j as b,N as c,P as d,D as e,w as i,b as o,m as q,K as s};
