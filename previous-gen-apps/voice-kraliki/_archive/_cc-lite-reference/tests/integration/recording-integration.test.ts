import { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';\nimport { RecordingService } from '../../server/services/recording-service';\nimport { RecordingComplianceService } from '../../server/services/recording-compliance-service';\nimport { PrismaClient, ConsentMethod, RecordingQuality, RecordingStatus } from '@prisma/client';\nimport { mockS3Client } from '../mocks/s3-mock';\n\ndescribe('Recording Integration Tests', () => {\n  let prisma: PrismaClient;\n  let recordingService: RecordingService;\n  let complianceService: RecordingComplianceService;\n  let testCallId: string;\n  let testUserId: string;\n  let testOrgId: string;\n\n  beforeAll(async () => {\n    // Initialize test database connection\n    prisma = new PrismaClient({\n      datasources: {\n        db: {\n          url: process.env.TEST_DATABASE_URL || process.env.DATABASE_URL\n        }\n      }\n    });\n\n    // Initialize services with test configuration\n    recordingService = new RecordingService(prisma, {\n      bucket: 'test-recordings-bucket',\n      region: 'us-east-1',\n      encryptionEnabled: true,\n      retentionDays: 30\n    });\n\n    complianceService = new RecordingComplianceService(prisma, {\n      defaultRetentionDays: 30,\n      maxRetentionDays: 365,\n      requireConsent: true,\n      autoDeleteExpired: false // Disable for testing\n    });\n\n    // Create test organization\n    const testOrg = await prisma.organization.create({\n      data: {\n        name: 'Test Recording Org',\n        domain: 'test-recording.local'\n      }\n    });\n    testOrgId = testOrg.id;\n\n    // Create test user\n    const testUser = await prisma.user.create({\n      data: {\n        email: 'test-recording@example.com',\n        firstName: 'Test',\n        lastName: 'User',\n        role: 'AGENT',\n        organizationId: testOrgId\n      }\n    });\n    testUserId = testUser.id;\n\n    // Create test call\n    const testCall = await prisma.call.create({\n      data: {\n        fromNumber: '+1234567890',\n        toNumber: '+0987654321',\n        status: 'IN_PROGRESS',\n        direction: 'INBOUND',\n        organizationId: testOrgId,\n        agentId: testUserId,\n        startTime: new Date()\n      }\n    });\n    testCallId = testCall.id;\n  });\n\n  afterAll(async () => {\n    // Cleanup test data\n    await prisma.recordingAuditLog.deleteMany();\n    await prisma.recording.deleteMany();\n    await prisma.call.deleteMany();\n    await prisma.user.deleteMany();\n    await prisma.organization.deleteMany();\n    await prisma.$disconnect();\n\n    // Stop compliance service\n    complianceService.destroy();\n  });\n\n  beforeEach(async () => {\n    // Clean up recordings between tests\n    await prisma.recordingAuditLog.deleteMany();\n    await prisma.recording.deleteMany();\n  });\n\n  describe('Recording Lifecycle', () => {\n    it('should start recording with valid consent', async () => {\n      const consent = {\n        given: true,\n        method: ConsentMethod.VERBAL,\n        timestamp: new Date(),\n        details: 'Customer provided verbal consent'\n      };\n\n      const result = await recordingService.startRecording(testCallId, consent, {\n        quality: RecordingQuality.STANDARD,\n        userId: testUserId,\n        organizationId: testOrgId\n      });\n\n      expect(result.recordingId).toBeDefined();\n      expect(result.controls).toBeDefined();\n\n      // Verify recording was created in database\n      const recording = await prisma.recording.findUnique({\n        where: { id: result.recordingId }\n      });\n\n      expect(recording).toBeDefined();\n      expect(recording!.callId).toBe(testCallId);\n      expect(recording!.consentGiven).toBe(true);\n      expect(recording!.consentMethod).toBe(ConsentMethod.VERBAL);\n      expect(recording!.status).toBe(RecordingStatus.RECORDING);\n      expect(recording!.quality).toBe(RecordingQuality.STANDARD);\n      expect(recording!.retentionDays).toBe(30);\n      expect(recording!.scheduledDeletion).toBeDefined();\n\n      // Verify audit log was created\n      const auditLogs = await prisma.recordingAuditLog.findMany({\n        where: { recordingId: result.recordingId }\n      });\n\n      expect(auditLogs).toHaveLength(1);\n      expect(auditLogs[0].action).toBe('STARTED');\n      expect(auditLogs[0].userId).toBe(testUserId);\n    });\n\n    it('should reject recording without consent', async () => {\n      const consent = {\n        given: false,\n        method: ConsentMethod.VERBAL,\n        timestamp: new Date()\n      };\n\n      await expect(recordingService.startRecording(testCallId, consent)).rejects.toThrow(\n        'Recording consent is required but not provided'\n      );\n    });\n\n    it('should pause and resume recording', async () => {\n      // Start recording first\n      const consent = {\n        given: true,\n        method: ConsentMethod.DIGITAL,\n        timestamp: new Date()\n      };\n\n      const result = await recordingService.startRecording(testCallId, consent, {\n        userId: testUserId\n      });\n\n      // Pause recording\n      await recordingService.pauseRecording(result.recordingId, testUserId);\n\n      let recording = await prisma.recording.findUnique({\n        where: { id: result.recordingId }\n      });\n      expect(recording!.status).toBe(RecordingStatus.PAUSED);\n\n      // Resume recording\n      await recordingService.resumeRecording(result.recordingId, testUserId);\n\n      recording = await prisma.recording.findUnique({\n        where: { id: result.recordingId }\n      });\n      expect(recording!.status).toBe(RecordingStatus.RECORDING);\n\n      // Verify audit trail\n      const auditLogs = await prisma.recordingAuditLog.findMany({\n        where: { recordingId: result.recordingId },\n        orderBy: { timestamp: 'asc' }\n      });\n\n      expect(auditLogs).toHaveLength(3); // Started, Paused, Resumed\n      expect(auditLogs[1].action).toBe('PAUSED');\n      expect(auditLogs[2].action).toBe('RESUMED');\n    });\n\n    it('should stop recording and mark as completed', async () => {\n      const consent = {\n        given: true,\n        method: ConsentMethod.WRITTEN,\n        timestamp: new Date()\n      };\n\n      const result = await recordingService.startRecording(testCallId, consent, {\n        userId: testUserId\n      });\n\n      // Stop recording\n      await recordingService.stopRecording(result.recordingId, testUserId);\n\n      const recording = await prisma.recording.findUnique({\n        where: { id: result.recordingId }\n      });\n      expect(recording!.status).toBe(RecordingStatus.COMPLETED);\n\n      // Verify stop action was logged\n      const auditLogs = await prisma.recordingAuditLog.findMany({\n        where: { \n          recordingId: result.recordingId,\n          action: 'STOPPED'\n        }\n      });\n      expect(auditLogs).toHaveLength(1);\n    });\n  });\n\n  describe('Compliance Features', () => {\n    it('should generate compliance report', async () => {\n      // Create test recordings with different scenarios\n      const recordings = await Promise.all([\n        // Recording with consent\n        prisma.recording.create({\n          data: {\n            callId: testCallId,\n            status: RecordingStatus.UPLOADED,\n            consentGiven: true,\n            consentMethod: ConsentMethod.VERBAL,\n            retentionDays: 30,\n            scheduledDeletion: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),\n            s3Bucket: 'test-bucket',\n            s3Key: 'test-key-1'\n          }\n        }),\n        // Recording without consent\n        prisma.recording.create({\n          data: {\n            callId: testCallId,\n            status: RecordingStatus.UPLOADED,\n            consentGiven: false,\n            retentionDays: 30,\n            scheduledDeletion: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),\n            s3Bucket: 'test-bucket',\n            s3Key: 'test-key-2'\n          }\n        }),\n        // Expired recording\n        prisma.recording.create({\n          data: {\n            callId: testCallId,\n            status: RecordingStatus.UPLOADED,\n            consentGiven: true,\n            consentMethod: ConsentMethod.DIGITAL,\n            retentionDays: 30,\n            scheduledDeletion: new Date(Date.now() - 24 * 60 * 60 * 1000), // Yesterday\n            s3Bucket: 'test-bucket',\n            s3Key: 'test-key-3'\n          }\n        })\n      ]);\n\n      const report = await complianceService.generateComplianceReport();\n\n      expect(report.totalRecordings).toBe(3);\n      expect(report.expiredRecordings).toBe(1);\n      expect(report.recordingsWithoutConsent).toBe(1);\n      expect(report.complianceIssues.length).toBeGreaterThan(0);\n\n      // Check for specific compliance issues\n      const consentIssue = report.complianceIssues.find(issue => issue.type === 'missing_consent');\n      expect(consentIssue).toBeDefined();\n      expect(consentIssue!.severity).toBe('high');\n    });\n\n    it('should update recording retention period', async () => {\n      const recording = await prisma.recording.create({\n        data: {\n          callId: testCallId,\n          status: RecordingStatus.UPLOADED,\n          consentGiven: true,\n          consentMethod: ConsentMethod.VERBAL,\n          retentionDays: 30,\n          scheduledDeletion: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),\n          s3Bucket: 'test-bucket',\n          s3Key: 'test-key'\n        }\n      });\n\n      const newRetentionDays = 90;\n      await complianceService.updateRecordingRetention(\n        recording.id,\n        newRetentionDays,\n        testUserId\n      );\n\n      const updatedRecording = await prisma.recording.findUnique({\n        where: { id: recording.id }\n      });\n\n      expect(updatedRecording!.retentionDays).toBe(newRetentionDays);\n      expect(updatedRecording!.scheduledDeletion!.getTime())\n        .toBeGreaterThan(recording.scheduledDeletion!.getTime());\n\n      // Verify audit log\n      const auditLog = await prisma.recordingAuditLog.findFirst({\n        where: {\n          recordingId: recording.id,\n          action: 'RETENTION_UPDATED'\n        }\n      });\n      expect(auditLog).toBeDefined();\n      expect(auditLog!.userId).toBe(testUserId);\n    });\n\n    it('should revoke consent and delete recording', async () => {\n      const recording = await prisma.recording.create({\n        data: {\n          callId: testCallId,\n          status: RecordingStatus.UPLOADED,\n          consentGiven: true,\n          consentMethod: ConsentMethod.VERBAL,\n          retentionDays: 30,\n          scheduledDeletion: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),\n          s3Bucket: 'test-bucket',\n          s3Key: 'test-key'\n        }\n      });\n\n      await complianceService.revokeConsent(\n        recording.id,\n        testUserId,\n        'Customer requested deletion under GDPR'\n      );\n\n      const updatedRecording = await prisma.recording.findUnique({\n        where: { id: recording.id }\n      });\n\n      expect(updatedRecording!.status).toBe(RecordingStatus.DELETED);\n      expect(updatedRecording!.consentGiven).toBe(false);\n      expect(updatedRecording!.deletedAt).toBeDefined();\n\n      // Verify audit logs for both consent revocation and deletion\n      const auditLogs = await prisma.recordingAuditLog.findMany({\n        where: { recordingId: recording.id },\n        orderBy: { timestamp: 'asc' }\n      });\n\n      expect(auditLogs.length).toBeGreaterThanOrEqual(2);\n      expect(auditLogs.some(log => log.action === 'CONSENT_REVOKED')).toBe(true);\n      expect(auditLogs.some(log => log.action === 'DELETED')).toBe(true);\n    });\n\n    it('should export recording data for compliance requests', async () => {\n      const recording = await prisma.recording.create({\n        data: {\n          callId: testCallId,\n          status: RecordingStatus.UPLOADED,\n          consentGiven: true,\n          consentMethod: ConsentMethod.DIGITAL,\n          retentionDays: 90,\n          scheduledDeletion: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000),\n          s3Bucket: 'test-bucket',\n          s3Key: 'test-key',\n          duration: 120,\n          fileSize: 1024000,\n          format: 'wav',\n          quality: RecordingQuality.HIGH\n        }\n      });\n\n      // Add some audit logs\n      await prisma.recordingAuditLog.createMany({\n        data: [\n          {\n            recordingId: recording.id,\n            userId: testUserId,\n            action: 'STARTED',\n            timestamp: new Date()\n          },\n          {\n            recordingId: recording.id,\n            userId: testUserId,\n            action: 'STOPPED',\n            timestamp: new Date()\n          }\n        ]\n      });\n\n      const exportData = await complianceService.exportRecordingData(recording.id);\n\n      expect(exportData.recordingInfo).toBeDefined();\n      expect(exportData.recordingInfo.id).toBe(recording.id);\n      expect(exportData.recordingInfo.consentGiven).toBe(true);\n      expect(exportData.recordingInfo.duration).toBe(120);\n      expect(exportData.recordingInfo.fileSize).toBe(1024000);\n\n      expect(exportData.callInfo).toBeDefined();\n      expect(exportData.callInfo.fromNumber).toBe('+1234567890');\n      expect(exportData.callInfo.toNumber).toBe('+0987654321');\n\n      expect(exportData.auditTrail).toBeDefined();\n      expect(exportData.auditTrail).toHaveLength(2);\n      expect(exportData.auditTrail[0].action).toBe('STARTED');\n      expect(exportData.auditTrail[1].action).toBe('STOPPED');\n    });\n  });\n\n  describe('Error Handling', () => {\n    it('should handle recording not found errors', async () => {\n      await expect(recordingService.pauseRecording('non-existent-id'))\n        .rejects.toThrow('Recording not found');\n\n      await expect(recordingService.resumeRecording('non-existent-id'))\n        .rejects.toThrow('Recording not found');\n\n      await expect(recordingService.stopRecording('non-existent-id'))\n        .rejects.toThrow('Recording not found');\n    });\n\n    it('should handle invalid state transitions', async () => {\n      const recording = await prisma.recording.create({\n        data: {\n          callId: testCallId,\n          status: RecordingStatus.COMPLETED,\n          consentGiven: true,\n          consentMethod: ConsentMethod.VERBAL,\n          retentionDays: 30,\n          scheduledDeletion: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),\n          s3Bucket: 'test-bucket',\n          s3Key: 'test-key'\n        }\n      });\n\n      // Try to pause a completed recording\n      await expect(recordingService.pauseRecording(recording.id))\n        .rejects.toThrow('Recording is not active');\n\n      // Try to resume a completed recording\n      await expect(recordingService.resumeRecording(recording.id))\n        .rejects.toThrow('Recording is not paused');\n    });\n\n    it('should handle excessive retention period', async () => {\n      const recording = await prisma.recording.create({\n        data: {\n          callId: testCallId,\n          status: RecordingStatus.UPLOADED,\n          consentGiven: true,\n          consentMethod: ConsentMethod.VERBAL,\n          retentionDays: 30,\n          scheduledDeletion: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),\n          s3Bucket: 'test-bucket',\n          s3Key: 'test-key'\n        }\n      });\n\n      await expect(\n        complianceService.updateRecordingRetention(recording.id, 500) // Exceeds max of 365\n      ).rejects.toThrow('Retention period cannot exceed 365 days');\n    });\n  });\n\n  describe('S3 Integration', () => {\n    it('should generate presigned URL for recording access', async () => {\n      const recording = await prisma.recording.create({\n        data: {\n          callId: testCallId,\n          status: RecordingStatus.UPLOADED,\n          consentGiven: true,\n          consentMethod: ConsentMethod.VERBAL,\n          retentionDays: 30,\n          scheduledDeletion: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),\n          s3Bucket: 'test-bucket',\n          s3Key: 'recordings/2024/01/01/test-call/test-recording.wav'\n        }\n      });\n\n      // Note: This would normally interact with real S3, but we're testing the logic\n      // In a real test environment, you'd mock the S3 client\n      try {\n        const url = await recordingService.generatePresignedUrl(\n          recording.id,\n          testUserId,\n          3600\n        );\n        // Would expect a valid presigned URL format\n        expect(url).toContain('amazonaws.com');\n      } catch (error) {\n        // Expected to fail in test environment without real S3 credentials\n        expect(error).toBeDefined();\n      }\n\n      // Verify access was logged\n      const auditLog = await prisma.recordingAuditLog.findFirst({\n        where: {\n          recordingId: recording.id,\n          action: 'ACCESSED'\n        }\n      });\n      expect(auditLog).toBeDefined();\n    });\n  });\n});