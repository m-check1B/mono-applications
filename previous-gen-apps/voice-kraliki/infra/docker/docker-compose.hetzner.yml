version: '3.8'

# ============================================================================
# Hetzner Production Deployment Configuration
# ============================================================================
# Optimized docker-compose configuration for Hetzner Cloud servers
#
# Features:
# - Production-ready service configurations
# - Resource limits optimized for Hetzner VPS
# - Health checks and auto-restart policies
# - Secure networking with internal communication
# - Volume persistence for data
#
# Usage:
#   docker compose -f docker-compose.hetzner.yml up -d
#
# Prerequisites:
# - Docker and Docker Compose installed on Hetzner server
# - .env.production file configured with secrets
# - PostgreSQL database (can be external or use postgres service below)
# ============================================================================

services:
  # ==========================================================================
  # PostgreSQL Database
  # ==========================================================================
  postgres:
    image: postgres:15-alpine
    container_name: operator-postgres
    restart: unless-stopped
    environment:
      POSTGRES_DB: ${POSTGRES_DB:-operator_demo}
      POSTGRES_USER: ${POSTGRES_USER:-postgres}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_INITDB_ARGS: "-E UTF8 --locale=en_US.UTF-8"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./backups:/backups
    ports:
      - "127.0.0.1:5432:5432"  # Only expose to localhost
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-postgres}"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 2G
        reservations:
          cpus: '0.5'
          memory: 512M
    networks:
      - operator-network
    command:
      - "postgres"
      - "-c"
      - "max_connections=200"
      - "-c"
      - "shared_buffers=256MB"
      - "-c"
      - "effective_cache_size=1GB"
      - "-c"
      - "maintenance_work_mem=64MB"
      - "-c"
      - "checkpoint_completion_target=0.9"
      - "-c"
      - "wal_buffers=16MB"
      - "-c"
      - "default_statistics_target=100"
      - "-c"
      - "random_page_cost=1.1"
      - "-c"
      - "effective_io_concurrency=200"
      - "-c"
      - "work_mem=2MB"
      - "-c"
      - "min_wal_size=1GB"
      - "-c"
      - "max_wal_size=4GB"

  # ==========================================================================
  # Redis Cache and Pub/Sub
  # ==========================================================================
  redis:
    image: redis:7-alpine
    container_name: operator-redis
    restart: unless-stopped
    command: >
      redis-server
      --appendonly yes
      --requirepass ${REDIS_PASSWORD}
      --maxmemory 512mb
      --maxmemory-policy allkeys-lru
      --save 900 1
      --save 300 10
      --save 60 10000
    volumes:
      - redis_data:/data
    # NO PORT EXPOSURE - Redis only accessible within Docker network
    healthcheck:
      test: ["CMD", "redis-cli", "--raw", "incr", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 512M
        reservations:
          cpus: '0.25'
          memory: 128M
    networks:
      - operator-network

  # ==========================================================================
  # Qdrant Vector Database
  # ==========================================================================
  qdrant:
    image: qdrant/qdrant:v1.7.0
    container_name: operator-qdrant
    restart: unless-stopped
    volumes:
      - qdrant_data:/qdrant/storage
    ports:
      - "127.0.0.1:6333:6333"  # REST API - localhost only
      - "127.0.0.1:6334:6334"  # gRPC - localhost only
    environment:
      QDRANT__SERVICE__GRPC_PORT: 6334
      QDRANT__LOG_LEVEL: INFO
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:6333/"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 2G
        reservations:
          cpus: '0.5'
          memory: 512M
    networks:
      - operator-network

  # ==========================================================================
  # Backend API (FastAPI)
  # ==========================================================================
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: operator-backend
    restart: unless-stopped
    env_file:
      - .env.production
    environment:
      # Application config
      APP_NAME: "Operator Demo 2026"
      VERSION: "2.0.0"
      ENVIRONMENT: production
      HOST: 0.0.0.0
      PORT: 8000
      DEBUG: "false"

      # CORS - Update with your domain
      CORS_ORIGINS: '["https://yourdomain.com", "https://api.yourdomain.com"]'

      # Security
      SECRET_KEY: ${SECRET_KEY}
      JWT_KEYS_DIR: /app/keys
      AUTH_COOKIE_NAME: ${AUTH_COOKIE_NAME:-auth_token}
      REFRESH_COOKIE_NAME: ${REFRESH_COOKIE_NAME:-refresh_token}
      AUTH_COOKIE_DOMAIN: ${AUTH_COOKIE_DOMAIN:-}
      AUTH_COOKIE_SECURE: "true"
      AUTH_COOKIE_SAMESITE: lax

      # Database
      DATABASE_URL: ${DATABASE_URL}

      # Redis
      REDIS_URL: redis://:${REDIS_PASSWORD}@redis:6379/0

      # Qdrant
      QDRANT_URL: http://qdrant:6333

      # AI Provider API Keys
      OPENAI_API_KEY: ${OPENAI_API_KEY:-}
      GEMINI_API_KEY: ${GEMINI_API_KEY:-}
      DEEPGRAM_API_KEY: ${DEEPGRAM_API_KEY:-}

      # Telephony Provider Credentials
      TWILIO_ACCOUNT_SID: ${TWILIO_ACCOUNT_SID:-}
      TWILIO_AUTH_TOKEN: ${TWILIO_AUTH_TOKEN:-}
      TELNYX_API_KEY: ${TELNYX_API_KEY:-}
      TELNYX_PUBLIC_KEY: ${TELNYX_PUBLIC_KEY:-}

      # Logging
      LOG_LEVEL: ${LOG_LEVEL:-INFO}
    ports:
      - "8000:8000"
    volumes:
      - jwt_keys:/app/keys
      - ./backend/uploads:/app/uploads
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      qdrant:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "python", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8000/health')"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 20s
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 2G
        reservations:
          cpus: '0.5'
          memory: 512M
    networks:
      - operator-network

  # ==========================================================================
  # Frontend (SvelteKit)
  # ==========================================================================
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    container_name: operator-frontend
    restart: unless-stopped
    environment:
      NODE_ENV: production
      PORT: 3000
      # Update with your domain
      PUBLIC_API_BASE_URL: ${PUBLIC_API_BASE_URL:-https://api.yourdomain.com}
      PUBLIC_EXTERNAL_API_BASE_URL: ${PUBLIC_EXTERNAL_API_BASE_URL:-https://api.yourdomain.com}
      PRIVATE_API_BASE_URL: http://backend:8000
      PUBLIC_AUTH_ENABLED: "true"
    ports:
      - "3000:3000"
    depends_on:
      backend:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "node", "-e", "require('http').get('http://localhost:3000/', (r) => {process.exit(r.statusCode >= 200 && r.statusCode < 400 ? 0 : 1)})"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 20s
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 1G
        reservations:
          cpus: '0.25'
          memory: 256M
    networks:
      - operator-network

  # ==========================================================================
  # Nginx Reverse Proxy (Optional - use if not using Traefik)
  # ==========================================================================
  nginx:
    image: nginx:alpine
    container_name: operator-nginx
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/ssl:/etc/nginx/ssl:ro
      - nginx_logs:/var/log/nginx
    depends_on:
      - backend
      - frontend
    healthcheck:
      test: ["CMD", "nginx", "-t"]
      interval: 30s
      timeout: 5s
      retries: 3
    networks:
      - operator-network
    profiles:
      - nginx  # Only start with --profile nginx

# ============================================================================
# Networks
# ============================================================================
networks:
  operator-network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16

# ============================================================================
# Volumes - Persistent data storage
# ============================================================================
volumes:
  postgres_data:
    driver: local
  redis_data:
    driver: local
  qdrant_data:
    driver: local
  jwt_keys:
    driver: local
  nginx_logs:
    driver: local
